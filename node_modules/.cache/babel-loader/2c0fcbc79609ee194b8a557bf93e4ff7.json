{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\yerik\\\\Desktop\\\\React\\\\my-website\\\\src\\\\Components\\\\Clock.jsx\";\nimport '../App.css';\nimport React, { Component } from 'react';\n\nclass Clock extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      date: new Date()\n    };\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(() => this.tick(), 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 29,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"h2\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 30,\n        columnNumber: 11\n      }\n    }, \"It is \", this.state.date.toLocaleTimeString(), \".\"), /*#__PURE__*/React.createElement(\"textarea\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 33,\n        columnNumber: 11\n      }\n    }, \"Text\"), /*#__PURE__*/React.createElement(\"select\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 35,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"option\", {\n      value: \"grapefruit\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 36,\n        columnNumber: 13\n      }\n    }, \"Grapefruit\"), /*#__PURE__*/React.createElement(\"option\", {\n      value: \"lime\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 37,\n        columnNumber: 13\n      }\n    }, \"Lime\"), /*#__PURE__*/React.createElement(\"option\", {\n      selected: true,\n      value: \"coconut\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 13\n      }\n    }, \"Coconut\"), /*#__PURE__*/React.createElement(\"option\", {\n      value: \"mango\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 13\n      }\n    }, \"Mango\")));\n  }\n\n} // constructor is called\n// renders for the first time\n// component did mount sets up a timer\n// browser calls the tick method every second\n// setState initiates rerenders\n// if the clock is ever removed, unmount is called\n\n\nexport default Clock; // react setState may be asyncronous because of batching (better performance)\n// Because props and state may be updated asynchronously, you should not rely on their values for calculating the next state.\n// this.setState({counter: this.state.counter + this.props.increment});\n// wrong\n// pass a function instead of an object\n// this.setState((state, props) => ({counter: state.counter + props.increment}));\n// right\n// data can flow down, children can have some info but don't know or care where it came from\n// cannot return false to prevent default behavior in React\n\nfunction handleClick(e) {\n  e.preventDefault();\n  console.log('The link was clicked.');\n} // e is a synthetic event. React defines these synthetic events, so you don’t need to worry about cross-browser compatibility.\n// class Toggle extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = {isToggleOn: true};\n//     // This binding is necessary to make `this` work in the callback\n//     this.handleClick = this.handleClick.bind(this);\n//   }\n//   handleClick() {\n//     this.setState(state => ({\n//       isToggleOn: !state.isToggleOn\n//     }));\n//   }\n//   render() {\n//     return (\n//       <button onClick={this.handleClick}>\n//         {this.state.isToggleOn ? 'ON' : 'OFF'}\n//       </button>\n//     );\n//   }\n// }\n// Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.\n// can not do binding with arrow functions\n// <button onClick={() => this.handleClick()}></button>\n// The problem with this syntax is that a different callback is created each time the button renders. \n// In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do \n// an extra re-rendering. \n// We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.\n// passing arguments to event handlers\n// <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n// <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n// In both cases, the e argument representing the React event will be passed as a second argument after the ID. \n// With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.\n// you might want a component to hide itself even though it was rendered by another component. \n// To do this return null instead of its render output. For example a Warning component:\n// if (!props.warn) {return null}\n// The best way to pick a key is to use a string that uniquely identifies a list item among its siblings\n// <li key={todo.id}></li>\n// don’t recommend using indexes for keys if the order of items may change. \n// This can negatively impact performance and may cause issues with component state\n// Keys serve as a hint to React but they don’t get passed to your components. \n// If you need the same value in your component, pass it explicitly as a prop with a different name:\n// In HTML, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update \n// it based on user input.","map":{"version":3,"sources":["C:/Users/yerik/Desktop/React/my-website/src/Components/Clock.jsx"],"names":["React","Component","Clock","constructor","props","state","date","Date","componentDidMount","timerID","setInterval","tick","componentWillUnmount","clearInterval","setState","render","toLocaleTimeString","handleClick","e","preventDefault","console","log"],"mappings":";AAAA,OAAO,YAAP;AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;;AAEA,MAAMC,KAAN,SAAoBD,SAApB,CAA8B;AAC1BE,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa;AAACC,MAAAA,IAAI,EAAE,IAAIC,IAAJ;AAAP,KAAb;AACD;;AAEDC,EAAAA,iBAAiB,GAAG;AAClB,SAAKC,OAAL,GAAeC,WAAW,CACxB,MAAM,KAAKC,IAAL,EADkB,EAExB,IAFwB,CAA1B;AAID;;AAEDC,EAAAA,oBAAoB,GAAG;AACrBC,IAAAA,aAAa,CAAC,KAAKJ,OAAN,CAAb;AACD;;AAEDE,EAAAA,IAAI,GAAG;AACL,SAAKG,QAAL,CAAc;AACZR,MAAAA,IAAI,EAAE,IAAIC,IAAJ;AADM,KAAd;AAGD;;AAEDQ,EAAAA,MAAM,GAAG;AACP,wBACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAW,KAAKV,KAAL,CAAWC,IAAX,CAAgBU,kBAAhB,EAAX,MADF,eAIE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAJF,eAME;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACE;AAAQ,MAAA,KAAK,EAAC,YAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBADF,eAEE;AAAQ,MAAA,KAAK,EAAC,MAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAFF,eAGE;AAAQ,MAAA,QAAQ,MAAhB;AAAiB,MAAA,KAAK,EAAC,SAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAHF,eAIE;AAAQ,MAAA,KAAK,EAAC,OAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAJF,CANF,CADF;AAeD;;AAvCyB,C,CA0C5B;AACA;AACA;AACA;AACA;AACA;;;AAEA,eAAed,KAAf,C,CAGF;AACA;AAGA;AACA;AAIA;AACA;AACA;AAGA;AAIA;;AACA,SAASe,WAAT,CAAqBC,CAArB,EAAwB;AACtBA,EAAAA,CAAC,CAACC,cAAF;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAY,uBAAZ;AACD,C,CAED;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AACA","sourcesContent":["import '../App.css';\r\nimport React, { Component } from 'react';\r\n\r\nclass Clock extends Component {\r\n    constructor(props) {\r\n      super(props);\r\n      this.state = {date: new Date()};\r\n    }\r\n  \r\n    componentDidMount() {\r\n      this.timerID = setInterval(\r\n        () => this.tick(),\r\n        1000\r\n      );\r\n    }\r\n  \r\n    componentWillUnmount() {\r\n      clearInterval(this.timerID);\r\n    }\r\n  \r\n    tick() {\r\n      this.setState({\r\n        date: new Date()\r\n      });\r\n    }\r\n  \r\n    render() {\r\n      return (\r\n        <div>\r\n          <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\r\n\r\n\r\n          <textarea>Text</textarea>\r\n\r\n          <select>\r\n            <option value=\"grapefruit\">Grapefruit</option>\r\n            <option value=\"lime\">Lime</option>\r\n            <option selected value=\"coconut\">Coconut</option>\r\n            <option value=\"mango\">Mango</option>\r\n          </select>\r\n        </div>\r\n      );\r\n    }\r\n  }\r\n  \r\n  // constructor is called\r\n  // renders for the first time\r\n  // component did mount sets up a timer\r\n  // browser calls the tick method every second\r\n  // setState initiates rerenders\r\n  // if the clock is ever removed, unmount is called\r\n\r\n  export default Clock;\r\n\r\n\r\n// react setState may be asyncronous because of batching (better performance)\r\n// Because props and state may be updated asynchronously, you should not rely on their values for calculating the next state.\r\n\r\n\r\n// this.setState({counter: this.state.counter + this.props.increment});\r\n// wrong\r\n\r\n\r\n\r\n// pass a function instead of an object\r\n// this.setState((state, props) => ({counter: state.counter + props.increment}));\r\n// right\r\n\r\n\r\n// data can flow down, children can have some info but don't know or care where it came from\r\n\r\n\r\n\r\n// cannot return false to prevent default behavior in React\r\nfunction handleClick(e) {\r\n  e.preventDefault();\r\n  console.log('The link was clicked.');\r\n}\r\n\r\n// e is a synthetic event. React defines these synthetic events, so you don’t need to worry about cross-browser compatibility.\r\n\r\n\r\n// class Toggle extends React.Component {\r\n//   constructor(props) {\r\n//     super(props);\r\n//     this.state = {isToggleOn: true};\r\n\r\n//     // This binding is necessary to make `this` work in the callback\r\n//     this.handleClick = this.handleClick.bind(this);\r\n//   }\r\n\r\n//   handleClick() {\r\n//     this.setState(state => ({\r\n//       isToggleOn: !state.isToggleOn\r\n//     }));\r\n//   }\r\n\r\n//   render() {\r\n//     return (\r\n//       <button onClick={this.handleClick}>\r\n//         {this.state.isToggleOn ? 'ON' : 'OFF'}\r\n//       </button>\r\n//     );\r\n//   }\r\n// }\r\n\r\n// Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.\r\n\r\n// can not do binding with arrow functions\r\n// <button onClick={() => this.handleClick()}></button>\r\n\r\n// The problem with this syntax is that a different callback is created each time the button renders. \r\n// In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do \r\n// an extra re-rendering. \r\n// We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.\r\n\r\n\r\n// passing arguments to event handlers\r\n// <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\r\n// <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\r\n\r\n\r\n// In both cases, the e argument representing the React event will be passed as a second argument after the ID. \r\n// With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.\r\n\r\n\r\n\r\n// you might want a component to hide itself even though it was rendered by another component. \r\n// To do this return null instead of its render output. For example a Warning component:\r\n\r\n// if (!props.warn) {return null}\r\n\r\n\r\n// The best way to pick a key is to use a string that uniquely identifies a list item among its siblings\r\n// <li key={todo.id}></li>\r\n\r\n// don’t recommend using indexes for keys if the order of items may change. \r\n// This can negatively impact performance and may cause issues with component state\r\n\r\n\r\n// Keys serve as a hint to React but they don’t get passed to your components. \r\n// If you need the same value in your component, pass it explicitly as a prop with a different name:\r\n\r\n\r\n// In HTML, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update \r\n// it based on user input."]},"metadata":{},"sourceType":"module"}